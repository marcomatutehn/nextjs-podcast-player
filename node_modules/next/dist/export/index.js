"use strict";exports.__esModule=true;exports.default=_default;var _os=require("os");var _child_process=require("child_process");var _recursiveCopy=require("../lib/recursive-copy");var _mkdirp=_interopRequireDefault(require("mkdirp"));var _path=require("path");var _fs=require("fs");var _chalk=_interopRequireDefault(require("chalk"));var _config=_interopRequireWildcard(require("next-server/dist/server/config"));var _constants=require("next-server/constants");var _ttyAwareProgress=_interopRequireDefault(require("tty-aware-progress"));var _util=require("util");var _recursiveDelete=require("../lib/recursive-delete");var _constants2=require("../lib/constants");var _index=require("../build/output/index");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj;}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}}newObj.default=obj;return newObj;}}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}const mkdirp=(0,_util.promisify)(_mkdirp.default);async function _default(dir,options,configuration){function log(message){if(options.silent)return;console.log(message);}dir=(0,_path.resolve)(dir);const nextConfig=configuration||(0,_config.default)(_constants.PHASE_EXPORT,dir);const concurrency=options.concurrency||10;const threads=options.threads||Math.max((0,_os.cpus)().length-1,1);const distDir=(0,_path.join)(dir,nextConfig.distDir);const subFolders=nextConfig.exportTrailingSlash;if(!options.buildExport&&nextConfig.target!=='server'){throw new Error('Cannot export when target is not server. https://err.sh/zeit/next.js/next-export-serverless');}log(`> using build directory: ${distDir}`);if(!(0,_fs.existsSync)(distDir)){throw new Error(`Build directory ${distDir} does not exist. Make sure you run "next build" before running "next start" or "next export".`);}const buildId=(0,_fs.readFileSync)((0,_path.join)(distDir,_constants.BUILD_ID_FILE),'utf8');const pagesManifest=!options.pages&&require((0,_path.join)(distDir,_constants.SERVER_DIRECTORY,_constants.PAGES_MANIFEST));const pages=options.pages||Object.keys(pagesManifest);const defaultPathMap={};for(const page of pages){// _document and _app are not real pages
// _error is exported as 404.html later on
// API Routes are Node.js functions
if(page==='/_document'||page==='/_app'||page==='/_error'||page.match(_constants2.API_ROUTE)){continue;}defaultPathMap[page]={page};}// Initialize the output directory
const outDir=options.outdir;await(0,_recursiveDelete.recursiveDelete)((0,_path.join)(outDir));await mkdirp((0,_path.join)(outDir,'_next',buildId));// Copy static directory
if((0,_fs.existsSync)((0,_path.join)(dir,'static'))){log('  copying "static" directory');await(0,_recursiveCopy.recursiveCopy)((0,_path.join)(dir,'static'),(0,_path.join)(outDir,'static'));}// Copy .next/static directory
if((0,_fs.existsSync)((0,_path.join)(distDir,_constants.CLIENT_STATIC_FILES_PATH))){log('  copying "static build" directory');await(0,_recursiveCopy.recursiveCopy)((0,_path.join)(distDir,_constants.CLIENT_STATIC_FILES_PATH),(0,_path.join)(outDir,'_next',_constants.CLIENT_STATIC_FILES_PATH));}// Get the exportPathMap from the config file
if(typeof nextConfig.exportPathMap!=='function'){console.log(`> No "exportPathMap" found in "${_constants.CONFIG_FILE}". Generating map from "./pages"`);nextConfig.exportPathMap=async defaultMap=>{return defaultMap;};}// Start the rendering process
const renderOpts={dir,buildId,nextExport:true,assetPrefix:nextConfig.assetPrefix.replace(/\/$/,''),distDir,dev:false,staticMarkup:false,hotReloader:null,canonicalBase:nextConfig.amp&&nextConfig.amp.canonicalBase||'',isModern:nextConfig.experimental.modern};const{serverRuntimeConfig,publicRuntimeConfig}=nextConfig;if(Object.keys(publicRuntimeConfig).length>0){renderOpts.runtimeConfig=publicRuntimeConfig;}// We need this for server rendering the Link component.
global.__NEXT_DATA__={nextExport:true};log(`  launching ${threads} threads with concurrency of ${concurrency} per thread`);const exportPathMap=await nextConfig.exportPathMap(defaultPathMap,{dev:false,dir,outDir,distDir,buildId});if(!exportPathMap['/404']){exportPathMap['/404.html']=exportPathMap['/404.html']||{page:'/_error'};}const exportPaths=Object.keys(exportPathMap);const filteredPaths=exportPaths.filter(// Remove API routes
route=>!exportPathMap[route].page.match(_constants2.API_ROUTE));const hasApiRoutes=exportPaths.length!==filteredPaths.length;// Warn if the user defines a path for an API page
if(hasApiRoutes){log(_chalk.default.yellow('  API pages are not supported by next export. https://err.sh/zeit/next.js/api-routes-static-export'));}const progress=!options.silent&&(0,_ttyAwareProgress.default)(filteredPaths.length);const chunks=filteredPaths.reduce((result,route,i)=>{const worker=i%threads;if(!result[worker]){result[worker]={paths:[],pathMap:{}};}result[worker].pathMap[route]=exportPathMap[route];result[worker].paths.push(route);if(options.sprPages&&options.sprPages.has(route)){result[worker].pathMap[route].sprPage=true;}return result;},[]);const ampValidations={};let hadValidationError=false;const publicDir=(0,_path.join)(dir,_constants.CLIENT_PUBLIC_FILES_PATH);// Copy public directory
if(nextConfig.experimental&&nextConfig.experimental.publicDirectory&&(0,_fs.existsSync)(publicDir)){log('  copying "public" directory');await(0,_recursiveCopy.recursiveCopy)(publicDir,outDir,{filter(path){// Exclude paths used by pages
return!exportPathMap[path];}});}const workers=new Set();await Promise.all(chunks.map(chunk=>new Promise((resolve,reject)=>{const worker=(0,_child_process.fork)(require.resolve('./worker'),[],{env:process.env});workers.add(worker);worker.send({distDir,buildId,exportPaths:chunk.paths,exportPathMap:chunk.pathMap,outDir,renderOpts,serverRuntimeConfig,concurrency,subFolders,serverless:(0,_config.isTargetLikeServerless)(nextConfig.target)});worker.on('message',({type,payload})=>{if(type==='progress'&&progress){progress();}else if(type==='error'){reject(payload);}else if(type==='done'){resolve();}else if(type==='amp-validation'){ampValidations[payload.page]=payload.result;hadValidationError=hadValidationError||payload.result.errors.length;}});})));workers.forEach(worker=>worker.kill());if(Object.keys(ampValidations).length){console.log((0,_index.formatAmpMessages)(ampValidations));}if(hadValidationError){throw new Error(`AMP Validation caused the export to fail. https://err.sh/zeit/next.js/amp-export-validation`);}// Add an empty line to the console for the better readability.
log('');}